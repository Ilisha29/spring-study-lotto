## 문자열 계산기 리팩토링

> Pattern, Matcher 클래스

```java
Pattern p = Pattern.compile('정규식');
```

```java
Matcher matcher = p.matcher("문자열");
```



- find() 
  - Pattern에 일치하는 텍스트가 발견 되면 true
- group()
  - 패턴과 일치하는 텍스트를 반환



> 정규식

| 표현식 |                    설명                    |
| :----: | :----------------------------------------: |
|   ^    |               문자열의 시작                |
|   $    |               문자열의 종료                |
|   .    |        임의의 한 문자 (줄바꿈 제외)        |
| [...]  | [] 사이에 있는 문자 혹은 문자집합 (ex A-Z) |
| [^...] |   [] 사이에 있는 문자 혹은 문자집합 제외   |
|   *    |    앞문자가 문자열일 많을수도 없을수도     |
|   +    |            앞 문자가 하나 이상             |
|   ?    |           앞 문자가 없거나 하나            |
|   {}   |               횟수 또는 범위               |
|   \d   |                   [0-9]                    |

더 많은 표현 : https://jamesdreaming.tistory.com/179

**자주 사용하는 거**

1. 숫자만 : ^[0-9]*$

2.  영문자만 : ^[a-zA-Z]*$

3.  한글만 : ^[가-힣]*$

4. 영어 & 숫자만 : ^[a-zA-Z0-9]*$

5. E-Mail : ^[a-zA-Z0-9]+@[a-zA-Z0-9]+$

6. 휴대폰 : ^01(?:0|1|[6-9]) - (?:\d{3}|\d{4}) - \d{4}$

7. 일반전화 : ^\d{2.3} - \d{3,4} - \d{4}$

8. 주민등록번호 : \d{6} \- [1-4]\d{6}

9. IP 주소 : ([0-9]{1,3}) \. ([0-9]{1,3}) \. ([0-9]{1,3}) \. ([0-9]{1,3})



`"//;\n1;2;3"`

```java
Matcher matcher = Pattern.compile("//(.)\n(.*)").matcher(string);
```

=> `//`와 `\n` 사이의 문자가 식의 구분자

```java
matcher.group(2), matcher.group(1) //group(2)는 1;2;3 group(1)은 ;
```



> Stream

- mapToInt() : 객체 스트림을 기본 타입 스트림으로 변환 (Stream -> IntStream)

- allMatch() : 모든 파라미터가 조건에 중촉되는지

```java
String[] str = ["1", "2", "3"];
Stream stream = Arrays.stream(str);
stream.mapToInt(num -> Integer.parseInt(num)).allMatch(num -> num > 0);
```



> 힘든점

- 정규식 표현을 읽기 힘들었다.
  - 정규식 사용 이유 : 코딩 시간절약, 특정 문자나 문자열 검색등등
  - 단점  : 가독성 떨어짐.

- 저번보다 리팩토리 시간을 줄였음.
- tdd -> 구현 -> 리팩토링 순서